[{"content":"1. 创建一个新的分支：  git branch newBranch\n 2. 查看分支是否创建成功：  git branch\n 3. 切换到新分区：  git checkout newBranch\n 4. 把代码直接提到newBranch分支上,如果出现提示,直接执行：  git push \u0026ndash;set-upstream origin newBranch\n 5. 切换回本想要提交代码的分区,把newBranch合并到 master分支上：  git checkout master\ngit merge newBranch\n 6. 删除新分区：  git branch -D newBranch\n 7. 重新提交一下代码：  git push\n ","permalink":"https://xiaotuanzijiang.github.io/posts/git%E9%97%AE%E9%A2%98/","summary":"1. 创建一个新的分支：  git branch newBranch\n 2. 查看分支是否创建成功：  git branch\n 3. 切换到新分区：  git checkout newBranch\n 4. 把代码直接提到newBranch分支上,如果出现提示,直接执行：  git push \u0026ndash;set-upstream origin newBranch\n 5. 切换回本想要提交代码的分区,把newBranch合并到 master分支上：  git checkout master\ngit merge newBranch\n 6. 删除新分区：  git branch -D newBranch\n 7. 重新提交一下代码：  git push\n ","title":"Git提交代码时出现Everything up-to-date"},{"content":"第 276 场周赛 2138. 将字符串拆分为若干长度为 k 的组 难度：简单\n 补全分割\n class Solution {\rpublic String[] divideString(String s, int k, char fill) {\rint num = s.length() % k;\rif(num != 0) {\rnum = k - num;\rwhile(num-- \u0026gt; 0) {\rs += fill;\r}\r}\rint len = s.length() / k;\rString[] ans = new String[len];\rfor(int i = 0; i \u0026lt; len; i++) {\rans[i] = s.substring(i*k, (i + 1) * k);\r}\rreturn ans;\r}\r}\r 2139. 得到目标值的最少行动次数 难度：中等\n 贪心\n class Solution {\rpublic int minMoves(int target, int maxDoubles) {\rint cnt = 0;\rwhile(target \u0026gt; 1) {\rif(maxDoubles \u0026gt; 0) {\rif((target \u0026amp; 1) == 1) target--;\relse {\rtarget \u0026gt;\u0026gt;= 1;\rmaxDoubles--;\r}\rcnt++;\r}else {\rreturn target + cnt - 1;\r}\r}\rreturn cnt;\r}\r}\r 2140. 解决智力问题 难度：中等\n 逆序dp\n class Solution {\rpublic long mostPoints(int[][] questions) {\rint n = questions.length;\rlong[] dp = new long[n + 1];\rfor(int i = n -1; i \u0026gt;= 0; i--) {\rif(questions[i][1] + i + 1 \u0026lt; n) {\rdp[i] = Math.max(dp[i + 1], dp[questions[i][1] + i + 1] + questions[i][0]);\r} else {\rdp[i] = Math.max(dp[i + 1], questions[i][0]);\r}\r}\rreturn dp[0];\r}\r}  第 275 场周赛 2133. 检查是否每一行每一列都包含全部整数 难度：简单\n HashSet\n class Solution {\rpublic boolean checkValid(int[][] matrix) {\rint len = matrix.length;\rHashSet\u0026lt;Integer\u0026gt; h1 = new HashSet\u0026lt;\u0026gt;();\rHashSet\u0026lt;Integer\u0026gt; h2 = new HashSet\u0026lt;\u0026gt;();\rfor(int i = 0; i \u0026lt; len; i++) {\rfor(int j = 0; j \u0026lt; len; j++) {\rh1.add(matrix[i][j]);\rh2.add(matrix[j][i]);\r}\rif(h1.size() != len || h2.size() != len) return false;\rh1.clear();\rh2.clear();\r}\rreturn true;\r}\r}\t 第 69 场双周赛 2129. 将标题首字母大写 难度：简单\n Api+Ascii\n class Solution {\rpublic String capitalizeTitle(String title) {\rString[] str = title.split(\u0026quot; \u0026quot;);\rfor(int i = 0; i \u0026lt; str.length; i++) {\rif(str[i].length() \u0026lt; 3) {\rstr[i] = str[i].toLowerCase();\r} else {\rchar[] c = str[i].toLowerCase().toCharArray();\rc[0] \u0026amp;= ~32;\rstr[i] = String.valueOf(c);\r}\r}\rreturn String.join(\u0026quot; \u0026quot;, str);\r}\r}\r 2130. 链表最大孪生和 难度：中等\n 链表转数组+双指针\n class Solution {\rpublic int pairSum(ListNode head) {\rif(head.next == null) return 0;\rList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;();\rwhile(head != null) {\rlist.add(head.val);\rhead = head.next;\r}\rInteger[] num = list.toArray(new Integer[0]);\rint mid = num.length \u0026gt;\u0026gt; 1;\rint max = 0;\rfor(int i = mid - 1; i \u0026gt;= 0; i--){\rmax = Math.max(max, num[i] + num[mid++]);\r}\rreturn max;\r}\r}\r 第 274 场周赛 2124. 检查是否所有 A 都在 B 之前 难度：简单\n 标记\n class Solution {\rpublic boolean checkString(String s) {\rchar[] cs = s.toCharArray();\rboolean na = false;\rfor(char c : cs) {\rif(c == 'a' \u0026amp;\u0026amp; na) return false;\rif(c != 'a') na = true;\r}\rreturn true;\r}\r}\r 2125. 银行中的激光束数量 难度：中等\n cnt * pre\n class Solution {\rpublic int numberOfBeams(String[] bank) {\rint ans = 0;\rint pre = 0;\rfor(String s : bank) {\rint cnt = 0;\rchar[] cs = s.toCharArray();\rfor(int i = 0; i \u0026lt; cs.length; i++) {\rcnt += cs[i] == '1' ? 1 : 0;\r}\rif(cnt != 0) {\rans += cnt * pre;\rpre = cnt;\r}\r}\rreturn ans;\r}\r}\r 2126. 摧毁小行星 难度：中等\n 排序+贪心\n class Solution {\rpublic boolean asteroidsDestroyed(int mass, int[] asteroids) {\rlong mas = mass;\rArrays.sort(asteroids);\rfor(int i : asteroids) {\rif(mas \u0026lt; i) return false;\rmas += i;\r}\rreturn true;\r}\r}\r 第 273 场周赛 2119. 反转两次的数字 难度：简单\n 末尾不为0\n class Solution {\rpublic boolean isSameAfterReversals(int num) {\rreturn !(num != 0 \u0026amp;\u0026amp; num % 10 == 0);\r}\r} ","permalink":"https://xiaotuanzijiang.github.io/posts/leetcode_%E5%91%A8%E8%B5%9B/","summary":"第 276 场周赛 2138. 将字符串拆分为若干长度为 k 的组 难度：简单\n 补全分割\n class Solution {\rpublic String[] divideString(String s, int k, char fill) {\rint num = s.length() % k;\rif(num != 0) {\rnum = k - num;\rwhile(num-- \u0026gt; 0) {\rs += fill;\r}\r}\rint len = s.length() / k;\rString[] ans = new String[len];\rfor(int i = 0; i \u0026lt; len; i++) {\rans[i] = s.substring(i*k, (i + 1) * k);\r}\rreturn ans;\r}\r}\r 2139.","title":"LeetCode_周赛"},{"content":"前端 - Color - CSSLayout - CSSGridGenerator - Uigradients - FreeDownloads 后端 - Binary Tree - BinaryTreeVisuakuser - Data Structure Visualizations - MvnRepository - MavenRepository - 阿里巴巴开源镜像站 其他 - MarkDown编辑器 - Eclipse主题 - Pexels - CodeLf - Favicon - RegexLearn ","permalink":"https://xiaotuanzijiang.github.io/posts/unitl/","summary":"前端 - Color - CSSLayout - CSSGridGenerator - Uigradients - FreeDownloads 后端 - Binary Tree - BinaryTreeVisuakuser - Data Structure Visualizations - MvnRepository - MavenRepository - 阿里巴巴开源镜像站 其他 - MarkDown编辑器 - Eclipse主题 - Pexels - CodeLf - Favicon - RegexLearn ","title":"UNTIL"},{"content":"1.19_LeetCode-219.存在重复元素II 难度：简单\nclass Solution {\rpublic boolean containsNearbyDuplicate(int[] nums, int k) {\rHashMap\u0026lt;Integer, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;();\rfor(int i = 0; i \u0026lt; nums.length; i++) {\rint num = nums[i];\rif(hashMap.containsKey(num)) {\rreturn true;\r}\rhashMap.put(num, null);\rif(hashMap.size() \u0026gt; k) {\rhashMap.remove(nums[i - k]);\r}\r}\rreturn false;\r}\r}\r ","permalink":"https://xiaotuanzijiang.github.io/posts/leetcode_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","summary":"1.19_LeetCode-219.存在重复元素II 难度：简单\nclass Solution {\rpublic boolean containsNearbyDuplicate(int[] nums, int k) {\rHashMap\u0026lt;Integer, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;();\rfor(int i = 0; i \u0026lt; nums.length; i++) {\rint num = nums[i];\rif(hashMap.containsKey(num)) {\rreturn true;\r}\rhashMap.put(num, null);\rif(hashMap.size() \u0026gt; k) {\rhashMap.remove(nums[i - k]);\r}\r}\rreturn false;\r}\r}\r ","title":"LeetCode_每日一题"}]