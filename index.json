[{"content":"一、七种遍历Map的方法、  1、forEach+Map.EntrySet for (Map.Entry\u0026lt;Integer, String\u0026gt; entry : map.entrySet()) { System.out.println(entry.getKey() + entry.getValue()); } 2、iterator+Map.Entry Iterator\u0026lt;Map.Entry\u0026lt;Integer, String\u0026gt;\u0026gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry\u0026lt;Integer, String\u0026gt; next = iterator.next(); System.out.println(next.getKey() + next.getValue()); } 3、keySet+forEach for (Integer key : map.keySet()) { System.out.println(key + map.get(key)); } 4、keySet+iterator Iterator\u0026lt;Integer\u0026gt; iterator = map.keySet().iterator(); while (iterator.hasNext()) { Integer next = iterator.next(); System.out.println(next + map.get(next)); } 5、entry+stream map.entrySet().stream().forEach(entry -\u0026gt; System.out.println(entry.getKey() + entry.getValue())); 6、stream并行 map.entrySet().stream().parallel().forEach(entry -\u0026gt; System.out.println(entry.getKey() + entry.getValue())); 7、forEach+lambda map.forEach((k, v) -\u0026gt; System.out.println(k + v)); Spring Boot:Could not find acceptable representation  原因是返回结果JsonResponse中没有具体参数的get方法 ","permalink":"https://xiaotuanzijiang.github.io/posts/java/","summary":"一、七种遍历Map的方法、  1、forEach+Map.EntrySet for (Map.Entry\u0026lt;Integer, String\u0026gt; entry : map.entrySet()) { System.out.println(entry.getKey() + entry.getValue()); } 2、iterator+Map.Entry Iterator\u0026lt;Map.Entry\u0026lt;Integer, String\u0026gt;\u0026gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry\u0026lt;Integer, String\u0026gt; next = iterator.next(); System.out.println(next.getKey() + next.getValue()); } 3、keySet+forEach for (Integer key : map.keySet()) { System.out.println(key + map.get(key)); } 4、keySet+iterator Iterator\u0026lt;Integer\u0026gt; iterator = map.keySet().iterator(); while (iterator.hasNext()) { Integer next = iterator.next(); System.out.println(next + map.get(next)); } 5、entry+stream map.entrySet().stream().forEach(entry -\u0026gt; System.out.println(entry.getKey() + entry.getValue())); 6、stream并行 map.entrySet().stream().parallel().forEach(entry -\u0026gt; System.out.println(entry.getKey() + entry.","title":"JAVA"},{"content":"安装  使用npm:\nnpm install dplayer --save 快速入门  新建VideoView.vue文件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div id=\u0026quot;dplayer\u0026quot; class=\u0026quot;play-root\u0026quot; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import DPlayer from 'dplayer'; export default { name: \u0026quot;optimizeVideo\u0026quot;, data() { return { dp:null, } }, methods:{ onPlay() { this.dp.play() } }, mounted() { //请求后端获取视频播放地址 var src = \u0026quot;http://localhost:9090/\u0026quot; + this.$route.query.url const dp = new DPlayer({ // 配置参数 container: document.getElementById('dplayer'), playbackSpeed: [0.5, 0.75, 1, 1.25, 1.5, 2, 3], //播放倍速 hotkey: true, //启用热键，支持FF，FR，音量控制，播放和暂停 autoplay: false, //视频自动播放 theme: '#00BFFF', //主题颜色 loop: true, lang: 'zh-cn', //语言 preload: 'auto', // logo: 'logo.png', volume: 0.7, //默认音量 video: { url: src, type: 'auto', quality: [ // 设置多个质量的视频 { name: \u0026quot;1080P\u0026quot;, url: src, type: \u0026quot;auto\u0026quot; // 'auto', 'hls', 'flv', 'dash', 'webtorrent', 'normal' 或 其他自定义类型 } ], defaultQuality: 0, }, }); // 禁止右键下载视频 document.oncontextmenu=new Function(\u0026quot;event.returnValue=false;\u0026quot;); document.onselectstart=new Function(\u0026quot;event.returnValue=false;\u0026quot;); // 修改循环播放显示 document.getElementsByClassName('dplayer-setting-item dplayer-setting-loop')[0].getElementsByClassName('dplayer-label')[0].innerText = \u0026quot;循环播放\u0026quot; // 修改倍速播放显示 document.getElementsByClassName('dplayer-setting-item dplayer-setting-speed')[0].getElementsByClassName('dplayer-label')[0].innerText = \u0026quot;播放倍速\u0026quot; //隐藏右键信息 document.querySelector(\u0026quot;.dplayer-menu\u0026quot;).remove() } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .play-root { width: auto; height: auto; margin: 0 auto; } \u0026lt;/style\u0026gt;   后端文件映射 package com.example.springbootvue.config; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MyWebConfig implements WebMvcConfigurer { @Override public void addResourceHandlers (ResourceHandlerRegistry registry) { registry.addResourceHandler(\u0026#34;/video/**\u0026#34;).addResourceLocations(\u0026#34;file:E:/video/\u0026#34;); } } ","permalink":"https://xiaotuanzijiang.github.io/posts/vue-dplayer/","summary":"安装  使用npm:\nnpm install dplayer --save 快速入门  新建VideoView.vue文件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div id=\u0026quot;dplayer\u0026quot; class=\u0026quot;play-root\u0026quot; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import DPlayer from 'dplayer'; export default { name: \u0026quot;optimizeVideo\u0026quot;, data() { return { dp:null, } }, methods:{ onPlay() { this.dp.play() } }, mounted() { //请求后端获取视频播放地址 var src = \u0026quot;http://localhost:9090/\u0026quot; + this.$route.query.url const dp = new DPlayer({ // 配置参数 container: document.getElementById('dplayer'), playbackSpeed: [0.5, 0.75, 1, 1.25, 1.5, 2, 3], //播放倍速 hotkey: true, //启用热键，支持FF，FR，音量控制，播放和暂停 autoplay: false, //视频自动播放 theme: '#00BFFF', //主题颜色 loop: true, lang: 'zh-cn', //语言 preload: 'auto', // logo: 'logo.","title":"Vue-Dplayer"},{"content":"application.yml spring:datasource:driver-class-name:com.mysql.cj.jdbc.Driverurl:jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2b8username:rootpassword:rootjpa:database:mysqldatabase-platform:org.hibernate.dialect.MySQL5InnoDBDialectshow-sql:truehibernate:ddl-auto:updateUser.java package com.example.springbootvue.entity; import com.fasterxml.jackson.annotation.JsonIgnore; import lombok.Data; import org.springframework.data.annotation.CreatedDate; import javax.persistence.*; import java.time.LocalDateTime; @Data @Entity @Table(name = \u0026#34;sys_user\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String username; @JsonIgnore private String password; private String nickname; private String email; private String phone; private String address; @CreatedDate private LocalDateTime createTime; } UserRepository package com.example.springbootvue.repository; import com.example.springbootvue.entity.User; import org.springframework.data.domain.Pageable; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import java.util.List; public interface UserRepository extends JpaRepository\u0026lt;User, Integer\u0026gt;, JpaSpecificationExecutor\u0026lt;User\u0026gt; { List\u0026lt;User\u0026gt; findAllByUsernameContainingAndAddressContaining (String likeUsername, String likeAddress, Pageable Pageable); } findAllByUsernameContainingAndAddressContaining -\u0026gt; 根据Username And Address进行模糊查询\nPageable -\u0026gt; 分页属性\nUserService package com.example.springbootvue.service; import com.example.springbootvue.repository.UserRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.stereotype.Service; import java.util.HashMap; import java.util.Map; @Service public class UserService { @Autowired private UserRepository userRepository; public Map\u0026lt;String, Object\u0026gt; findAllByPageNumAndSearch (Integer pageNum, String likeUsername, String likeAddress) { Map\u0026lt;String, Object\u0026gt; resMap = new HashMap\u0026lt;\u0026gt;(); Pageable pageable = PageRequest.of(pageNum - 1, 8); resMap.put(\u0026#34;data\u0026#34;, userRepository.findAllByUsernameContainingAndAddressContaining(likeUsername, likeAddress, pageable)); resMap.put(\u0026#34;total\u0026#34;, userRepository.count()); return resMap; } } UserController package com.example.springbootvue.controller; import com.example.springbootvue.repository.UserRepository; import com.example.springbootvue.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.Map; @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { @Autowired private UserService userService; @Autowired private UserRepository userRepository; @RequestMapping(\u0026#34;/page\u0026#34;) public Map\u0026lt;String, Object\u0026gt; getUserInfo (Integer pageNum, String likeUsername, String likeAddress) { return userService.findAllByPageNumAndSearch(pageNum, likeUsername, likeAddress); } } CorsConfig(跨域配置) package com.example.springbootvue.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; @Configuration public class CorsConfig { private static final long MAX_AGE = 24 * 60 * 60; private CorsConfiguration buildConfig () { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(\u0026#34;*\u0026#34;); corsConfiguration.addAllowedHeader(\u0026#34;*\u0026#34;); corsConfiguration.addAllowedMethod(\u0026#34;*\u0026#34;); corsConfiguration.setMaxAge(MAX_AGE); return corsConfiguration; } @Bean public CorsFilter corsFilter () { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\u0026#34;/**\u0026#34;, buildConfig()); return new CorsFilter(source); } }  ","permalink":"https://xiaotuanzijiang.github.io/posts/springboot/","summary":"application.yml spring:datasource:driver-class-name:com.mysql.cj.jdbc.Driverurl:jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2b8username:rootpassword:rootjpa:database:mysqldatabase-platform:org.hibernate.dialect.MySQL5InnoDBDialectshow-sql:truehibernate:ddl-auto:updateUser.java package com.example.springbootvue.entity; import com.fasterxml.jackson.annotation.JsonIgnore; import lombok.Data; import org.springframework.data.annotation.CreatedDate; import javax.persistence.*; import java.time.LocalDateTime; @Data @Entity @Table(name = \u0026#34;sys_user\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String username; @JsonIgnore private String password; private String nickname; private String email; private String phone; private String address; @CreatedDate private LocalDateTime createTime; } UserRepository package com.example.springbootvue.repository; import com.example.springbootvue.entity.User; import org.springframework.data.domain.Pageable; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import java.util.List; public interface UserRepository extends JpaRepository\u0026lt;User, Integer\u0026gt;, JpaSpecificationExecutor\u0026lt;User\u0026gt; { List\u0026lt;User\u0026gt; findAllByUsernameContainingAndAddressContaining (String likeUsername, String likeAddress, Pageable Pageable); } findAllByUsernameContainingAndAddressContaining -\u0026gt; 根据Username And Address进行模糊查询","title":"SpringBoot + SpringData Jpa"},{"content":"LeetCode 7-24-1184. 公交站间的距离 难度：简单\n 模拟\n func distanceBetweenBusStops(distance []int, start int, destination int) int { if start \u0026gt; destination { return distanceBetweenBusStops(distance, destination, start) } aSum := 0 bSum := 0 for i := 0; i \u0026lt; len(distance); i++ { if i \u0026gt;= start \u0026amp;\u0026amp; i \u0026lt; destination { aSum += distance[i] } else { bSum += distance[i] } } return int(math.Min(float64(aSum), float64(bSum))) } 6-21-1108. IP 地址无效化 难度：简单\n 模拟\n func defangIPaddr(address string) string { return strings.ReplaceAll(address, \u0026#34;.\u0026#34;, \u0026#34;[.]\u0026#34;) } func defangIPaddr(address string) string { var s strings.Builder for i := range address { if address[i] == \u0026#39;.\u0026#39; { s.WriteString(\u0026#34;[.]\u0026#34;) } else { s.WriteByte(address[i]) } } return s.String() } 6.13-1051. 高度检查器 难度：简单\n 模拟\n func heightChecker(heights []int) int { n := len(heights) cnt := 0 ars := make([]int, n) copy(ars, heights) sort.Ints(ars) for i:= 0; i \u0026lt; n; i++ { if ars[i] != heights[i] { cnt++ } } return cnt } 6.2-450. 删除二叉搜索树中的节点 难度：中等\n 递归\n /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func deleteNode(root *TreeNode, key int) *TreeNode { if root != nil { if root.Val \u0026lt; key { root.Right = deleteNode(root.Right, key) } else if root.Val \u0026gt; key { root.Left = deleteNode(root.Left, key) } else { if root.Left == nil || root.Right == nil { if root.Left != nil { root = root.Left } else { root = root.Right } } else { node := root.Left for node.Right != nil { node = node.Right } node.Left = deleteNode(root.Left, node.Val) node.Right = root.Right root = node } } } return root } 5.30-1022. 从根到叶的二进制数之和 难度：简单\n DFS\n /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sumRootToLeaf(root *TreeNode) int { return dfs(root, 0) } func dfs(node *TreeNode, a int) int{ if node != nil { a = a * 2 + node.Val if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { return a } return dfs(node.Left, a) + dfs(node.Right, a) } return 0 } 5.29-468. 验证IP地址 难度：中等\n 模拟\n func validIPAddress(queryIP string) string { if strings.Contains(queryIP, \u0026#34;.\u0026#34;) { str := strings.Split(queryIP, \u0026#34;.\u0026#34;) if len(str) != 4 { return \u0026#34;Neither\u0026#34; } for _, v := range str { strLen := len(v) num, _ := strconv.Atoi(v) strNum := len(strconv.Itoa(num)) if strLen != strNum || num \u0026gt; 255 || num \u0026lt; 0{ return \u0026#34;Neither\u0026#34; } } return \u0026#34;IPv4\u0026#34; } else { str := strings.Split(queryIP, \u0026#34;:\u0026#34;) if len(str) != 8 { return \u0026#34;Neither\u0026#34; } for _, v := range str { strLen := len(v) if strLen \u0026gt; 4 || strLen == 0 { return \u0026#34;Neither\u0026#34; } bytes := []byte(v) for _, b := range bytes { if !unicode.IsNumber(rune(b)) { if b \u0026lt; 65 || (b \u0026gt; 70 \u0026amp;\u0026amp; b \u0026lt; 97) || b \u0026gt; 102{ return \u0026#34;Neither\u0026#34; } } } } return \u0026#34;IPv6\u0026#34; } } 5.24-965. 单值二叉树 难度：简单\n DFS\n /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isUnivalTree(root *TreeNode) bool { val := root.Val var Find func(node *TreeNode) bool Find = func(node *TreeNode) bool { if node == nil { return true } return node.Val == val \u0026amp;\u0026amp; Find(node.Left) \u0026amp;\u0026amp; Find(node.Right) } return Find(root) } 5.21-961. 在长度 2N 的数组中找出重复 N 次的元素 难度：简单\n 模拟\n func repeatedNTimes(nums []int) int { hash := map[int]int{} for _, num := range nums { if hash[num] == 1 { return num } hash[num]++ } return -1 } 3.28-693. 交替位二进制数 难度：简单\n 模拟\n class Solution { public boolean hasAlternatingBits(int n) { while(n \u0026gt; 0){ if((n \u0026amp; 1) + (n \u0026gt;\u0026gt; 1 \u0026amp; 1) != 1) return false; n \u0026gt;\u0026gt;= 1; } return true; } }  位运算\n class Solution { public boolean hasAlternatingBits(int n) { int x = n ^ (n \u0026gt;\u0026gt; 1); return (x \u0026amp; (x + 1)) == 0; } } 3.26-682. 棒球比赛 难度：简单\n 模拟\n class Solution { public int calPoints(String[] ops) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for(String s : ops){ int size = list.size(); if(\u0026#34;C\u0026#34;.equals(s)){ list.remove(size - 1); } else if(\u0026#34;+\u0026#34;.equals(s)){ list.add(list.get(size - 1) + list.get(size - 2)); } else if(\u0026#34;D\u0026#34;.equals(s)){ list.add(list.get(size - 1) \u0026lt;\u0026lt; 1); } else{ list.add(Integer.parseInt(s)); } } return list.stream().reduce(Integer::sum).orElse(0); } } 3.22-2038. 如果相邻两个颜色均相同则删除当前颜色 难度：中等\n 脑筋急转弯\n class Solution { public boolean winnerOfGame(String colors) { char[] cs = colors.toCharArray(); int n = cs.length; int Acnt = 0, Bcnt = 0; for (int i = 1; i \u0026lt; n - 1; i++) { if (cs[i] == \u0026#39;A\u0026#39; \u0026amp;\u0026amp; cs[i - 1] == \u0026#39;A\u0026#39; \u0026amp;\u0026amp; cs[i + 1] == \u0026#39;A\u0026#39;) Acnt++; if (cs[i] == \u0026#39;B\u0026#39; \u0026amp;\u0026amp; cs[i - 1] == \u0026#39;B\u0026#39; \u0026amp;\u0026amp; cs[i + 1] == \u0026#39;B\u0026#39;) Bcnt++; } return Acnt \u0026gt; Bcnt; } } 3.18-2043. 简易银行系统 难度：中等\n 模拟\n class Bank { private long[] accounts; private int accountSize; public Bank(long[] balance) { accounts = balance; accountSize = balance.length; } public boolean transfer(int account1, int account2, long money) { if(account1 \u0026gt; accountSize || account2 \u0026gt; accountSize || account1 \u0026lt;= 0 || account2 \u0026lt;= 0) return false; if(accounts[--account1] \u0026lt; money) return false; accounts[account1] -= money; accounts[--account2] += money; return true; } public boolean deposit(int account, long money) { if(account \u0026lt;= 0 || account \u0026gt; accountSize) return false; accounts[--account] += money; return true; } public boolean withdraw(int account, long money) { if(account \u0026lt;= 0 || account \u0026gt; accountSize || accounts[--account] \u0026lt; money) return false; accounts[account] -= money; return true; } } /** * Your Bank object will be instantiated and called as such: * Bank obj = new Bank(balance); * boolean param_1 = obj.transfer(account1,account2,money); * boolean param_2 = obj.deposit(account,money); * boolean param_3 = obj.withdraw(account,money); */ 2.2-917. 仅仅反转字母 难度：简单\n 双指针\n class Solution { public String reverseOnlyLetters(String s) { char[] cs = s.toCharArray(); int l = 0, r = cs.length - 1; while(l \u0026lt; r){ if(Character.isLetter(cs[l])){ if(Character.isLetter(cs[r])){ char tmp = cs[l]; cs[l++] = cs[r]; cs[r--] = tmp; } else{ r--; } }else{ l++; } } return String.valueOf(cs); } } 2.20-717. 1比特与2比特字符 难度：简单\n 模拟\n class Solution { public boolean isOneBitCharacter(int[] bits) { int n = bits.length, i = 0; while(i \u0026lt; n - 1){ if(bits[i] == 0) i++; else i += 2; } return i == n - 1; } } 2.18-791. 找出星型图的中心节点 难度：简单\n HashMap\n class Solution { public int findCenter (int[][] edges) { HashMap\u0026lt;Integer, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); int res = 0; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 2; j++) { if (hashMap.containsKey(edges[i][j])) { res = edges[i][j]; } hashMap.put(edges[i][j], 0); } } return res; } }  模拟\n class Solution { public int findCenter(int[][] edges) { return edges[0][0] == edges[1][0] ? edges[1][0] : edges[0][0] == edges[1][1] ? edges[1][1] : edges[0][1] == edges[1][0] ? edges[1][0] : edges[1][1]; } } 2.15-1380. 矩阵中的幸运数 难度：简单\n 模拟\n class Solution { public List\u0026lt;Integer\u0026gt; luckyNumbers (int[][] matrix) { List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int m = matrix.length, n = matrix[0].length; int[] row = new int[m]; int[] col = new int[n]; for(int i = 0; i \u0026lt; m; i++){ row[i] = Integer.MAX_VALUE; for(int j = 0; j \u0026lt; n; j++){ row[i] = Math.min(matrix[i][j],row[i]); col[j] = Math.max(matrix[i][j],col[j]); } } for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (matrix[i][j] == row[i] \u0026amp;\u0026amp; matrix[i][j] == col[j]) { ans.add(matrix[i][j]); return ans; } } } return ans; } } 2.14-540. 有序数组中的单一元素 难度：中等\n 二分\n class Solution { public int singleNonDuplicate(int[] nums) { int n = nums.length; int l = 0,r = n - 1; while(l \u0026lt; r){ int mid = (l + r) \u0026gt;\u0026gt; 1; if((mid \u0026amp; 1) == 0){ if (mid + 1 \u0026lt; n \u0026amp;\u0026amp; nums[mid] == nums[mid + 1]) l = mid + 1; else r = mid; }else{ if (mid - 1 \u0026gt;= 0 \u0026amp;\u0026amp; nums[mid - 1] == nums[mid]) l = mid + 1; else r = mid; } } return nums[r]; } } 2.11-1984. 学生分数的最小差值 难度：简单\n 排序+动态窗口\n class Solution { public int minimumDifference(int[] nums, int k) { Arrays.sort(nums); int ans = Integer.MAX_VALUE; for (int i = 0; i \u0026lt;= nums.length - k; i++) { ans = Math.min(ans, nums[i + k - 1] - nums[i]); } return ans; } } 2.4-1725. 可以形成最大正方形的矩形数目 难度：简单\n 模拟\n class Solution { public int countGoodRectangles(int[][] rectangles) { int max = 0, ans = 0; for (int[] r : rectangles) { int cur = Math.min(r[0], r[1]); if (cur == max) ans++; else if (cur \u0026gt; max) { max = cur; ans = 1; } } return ans; } } 2.2-2000. 反转单词前缀 难度：简单\n 模拟\n class Solution { public String reversePrefix(String word, char ch) { StringBuilder sb = new StringBuilder(); char[] cs = word.toCharArray(); boolean isone = true; for (int i = 0; i \u0026lt; cs.length; i++) { sb.append(cs[i]); if(cs[i] == ch \u0026amp;\u0026amp; isone){ isone = false; sb.reverse(); } } return sb.toString(); } } 1.31-1342. 将数字变成 0 的操作次数 难度：简单\n 模拟\n class Solution { public int numberOfSteps(int num) { int con = 0; while (num != 0) { num = (num \u0026amp; 1) == 0 ? num \u0026gt;\u0026gt; 1 : num - 1; con++; } return con; } } 1.30-884. 两句话中的不常见单词 难度：简单\n HashMap\n class Solution { public String[] uncommonFromSentences(String s1, String s2) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); count(s1, map); count(s2, map); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); map.forEach((k, v) -\u0026gt; { if (v == 1) { list.add(k); } }); return list.toArray(new String[list.size()]); } private void count(String s, Map\u0026lt;String, Integer\u0026gt; map) { for (String a : s.split(\u0026#34; \u0026#34;)) { map.put(a, map.getOrDefault(a, 0) + 1); } } } 1.28-1996. 游戏中弱角色的数量 难度：中等\n 排序\n class Solution { public int numberOfWeakCharacters(int[][] properties) { Arrays.sort(properties,(a,b)-\u0026gt;{ return a[0] == b[0] ? (a[1] - b[1]) : (b[0] - a[0]); }); int cnt = 0; int temp = 0; for (int[] p : properties) { if(p[1] \u0026lt; temp) cnt++; else temp = p[1]; } return cnt; } } 1.27-2047. 句子中的有效单词数 难度：简单\n 模拟\n class Solution { public int countValidWords(String sentence) { String[] ss = sentence.split(\u0026#34; \u0026#34;); int ans = 0; for (String s : ss) if (check(s)) ans++; return ans; } boolean check(String s) { int n = s.length(); if (n == 0) return false; for (int i = 0, c1 = 0, c2 = 0; i \u0026lt; n; i++) { char c = s.charAt(i); if (Character.isDigit(c)) return false; if (c == \u0026#39; \u0026#39;) return false; if (c == \u0026#39;-\u0026#39; \u0026amp;\u0026amp; ++c1 \u0026gt;= 0) { if (c1 \u0026gt; 1 || (i == 0 || i == n - 1)) return false; if (!Character.isLetter(s.charAt(i - 1)) || !Character.isLetter(s.charAt(i + 1))) return false; } if ((c == \u0026#39;!\u0026#39; || c == \u0026#39;.\u0026#39; || c == \u0026#39;,\u0026#39;) \u0026amp;\u0026amp; ++c2 \u0026gt;= 0) { if (c2 \u0026gt; 1 || (i != n - 1)) return false; } } return true; } } 1.25-1688. 比赛中的配对次数 难度：简单\n 脑筋急转弯\n class Solution { public int numberOfMatches(int n) { return n - 1; } } 1.22-1332. 删除回文子序列 难度：简单\n 模拟\n class Solution { public int removePalindromeSub(String s) { int n = s.length(); for(int i = 0; i \u0026lt; (n \u0026gt;\u0026gt; 1); i++) if(s.charAt(i) != s.charAt(n-1-i)) return 2; return 1; } } 1.19-219.存在重复元素II 难度：简单\n HashMap\n class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { HashMap\u0026lt;Integer, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; nums.length; i++) { int num = nums[i]; if(hashMap.containsKey(num)) { return true; } hashMap.put(num, null); if(hashMap.size() \u0026gt; k) { hashMap.remove(nums[i - k]); } } return false; } } LeetCode_周赛 第 276 场周赛 2138. 将字符串拆分为若干长度为 k 的组 难度：简单\n 补全分割\n class Solution { public String[] divideString(String s, int k, char fill) { int num = s.length() % k; if(num != 0) { num = k - num; while(num-- \u0026gt; 0) { s += fill; } } int len = s.length() / k; String[] ans = new String[len]; for(int i = 0; i \u0026lt; len; i++) { ans[i] = s.substring(i*k, (i + 1) * k); } return ans; } } 2139. 得到目标值的最少行动次数 难度：中等\n 贪心\n class Solution { public int minMoves(int target, int maxDoubles) { int cnt = 0; while(target \u0026gt; 1) { if(maxDoubles \u0026gt; 0) { if((target \u0026amp; 1) == 1) target--; else { target \u0026gt;\u0026gt;= 1; maxDoubles--; } cnt++; }else { return target + cnt - 1; } } return cnt; } } 2140. 解决智力问题 难度：中等\n 逆序dp\n class Solution { public long mostPoints(int[][] questions) { int n = questions.length; long[] dp = new long[n + 1]; for(int i = n -1; i \u0026gt;= 0; i--) { if(questions[i][1] + i + 1 \u0026lt; n) { dp[i] = Math.max(dp[i + 1], dp[questions[i][1] + i + 1] + questions[i][0]); } else { dp[i] = Math.max(dp[i + 1], questions[i][0]); } } return dp[0]; } } 第 275 场周赛 2133. 检查是否每一行每一列都包含全部整数 难度：简单\n HashSet\n class Solution { public boolean checkValid(int[][] matrix) { int len = matrix.length; HashSet\u0026lt;Integer\u0026gt; h1 = new HashSet\u0026lt;\u0026gt;(); HashSet\u0026lt;Integer\u0026gt; h2 = new HashSet\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; len; i++) { for(int j = 0; j \u0026lt; len; j++) { h1.add(matrix[i][j]); h2.add(matrix[j][i]); } if(h1.size() != len || h2.size() != len) return false; h1.clear(); h2.clear(); } return true; } } 第 69 场双周赛 2129. 将标题首字母大写 难度：简单\n Api+Ascii\n class Solution { public String capitalizeTitle(String title) { String[] str = title.split(\u0026#34; \u0026#34;); for(int i = 0; i \u0026lt; str.length; i++) { if(str[i].length() \u0026lt; 3) { str[i] = str[i].toLowerCase(); } else { char[] c = str[i].toLowerCase().toCharArray(); c[0] \u0026amp;= ~32; str[i] = String.valueOf(c); } } return String.join(\u0026#34; \u0026#34;, str); } } 2130. 链表最大孪生和 难度：中等\n 链表转数组+双指针\n class Solution { public int pairSum(ListNode head) { if(head.next == null) return 0; List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); while(head != null) { list.add(head.val); head = head.next; } Integer[] num = list.toArray(new Integer[0]); int mid = num.length \u0026gt;\u0026gt; 1; int max = 0; for(int i = mid - 1; i \u0026gt;= 0; i--){ max = Math.max(max, num[i] + num[mid++]); } return max; } } 第 274 场周赛 2124. 检查是否所有 A 都在 B 之前 难度：简单\n 标记\n class Solution { public boolean checkString(String s) { char[] cs = s.toCharArray(); boolean na = false; for(char c : cs) { if(c == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; na) return false; if(c != \u0026#39;a\u0026#39;) na = true; } return true; } } 2125. 银行中的激光束数量 难度：中等\n cnt * pre\n class Solution { public int numberOfBeams(String[] bank) { int ans = 0; int pre = 0; for(String s : bank) { int cnt = 0; char[] cs = s.toCharArray(); for(int i = 0; i \u0026lt; cs.length; i++) { cnt += cs[i] == \u0026#39;1\u0026#39; ? 1 : 0; } if(cnt != 0) { ans += cnt * pre; pre = cnt; } } return ans; } } 2126. 摧毁小行星 难度：中等\n 排序+贪心\n class Solution { public boolean asteroidsDestroyed(int mass, int[] asteroids) { long mas = mass; Arrays.sort(asteroids); for(int i : asteroids) { if(mas \u0026lt; i) return false; mas += i; } return true; } } 第 273 场周赛 2119. 反转两次的数字 难度：简单\n 末尾不为0\n class Solution { public boolean isSameAfterReversals(int num) { return !(num != 0 \u0026amp;\u0026amp; num % 10 == 0); } } LeetCode_Other 169. 多数元素 难度：简单\n 脑筋急转弯\n class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length \u0026gt;\u0026gt; 1]; } }  摩尔投票法\n class Solution { public int majorityElement(int[] nums) { int cnt = 0; int temp = 0; for(int i : nums) { if(cnt == 0) { temp = i; cnt = 1; }else { cnt += temp != i ? -1 : 1; } } return temp; } }  \r","permalink":"https://xiaotuanzijiang.github.io/posts/leetcode/","summary":"LeetCode 7-24-1184. 公交站间的距离 难度：简单\n 模拟\n func distanceBetweenBusStops(distance []int, start int, destination int) int { if start \u0026gt; destination { return distanceBetweenBusStops(distance, destination, start) } aSum := 0 bSum := 0 for i := 0; i \u0026lt; len(distance); i++ { if i \u0026gt;= start \u0026amp;\u0026amp; i \u0026lt; destination { aSum += distance[i] } else { bSum += distance[i] } } return int(math.Min(float64(aSum), float64(bSum))) } 6-21-1108. IP 地址无效化 难度：简单\n 模拟","title":"LeetCode"},{"content":"Git提交代码时出现Everything up-to-date 2\n1. 创建一个新的分支  git branch newBranch\n 2. 查看分支是否创建成功：  git branch\n 3. 切换到新分区：  git checkout newBranch\n 4. 把代码直接提到newBranch分支上,如果出现提示,直接执行：  git push \u0026ndash;set-upstream origin newBranch\n 5. 切换回本想要提交代码的分区,把newBranch合并到 master分支上：  git checkout master\ngit merge newBranch\n 6. 删除新分区：  git branch -D newBranch\n 7. 重新提交一下代码：  git push\n  Git-error: failed to push some refs to 1.执行如下命令  git pull \u0026ndash;rebase origin master\n 2.重新上传  git push -u origin master\n  Git Push error: ssh: connect to host ssh.github.com port 443: Connection refused 1.找到当前用户目录下的.ssh/config 文件，如果没有就自己建一个。只要将Hostname ssh.github.com换成ip地址140.82.114.36即可  Host github.com\nHostname 140.82.114.36\nPort 443\n   ","permalink":"https://xiaotuanzijiang.github.io/posts/git/","summary":"Git提交代码时出现Everything up-to-date 2\n1. 创建一个新的分支  git branch newBranch\n 2. 查看分支是否创建成功：  git branch\n 3. 切换到新分区：  git checkout newBranch\n 4. 把代码直接提到newBranch分支上,如果出现提示,直接执行：  git push \u0026ndash;set-upstream origin newBranch\n 5. 切换回本想要提交代码的分区,把newBranch合并到 master分支上：  git checkout master\ngit merge newBranch\n 6. 删除新分区：  git branch -D newBranch\n 7. 重新提交一下代码：  git push\n  Git-error: failed to push some refs to 1.执行如下命令  git pull \u0026ndash;rebase origin master","title":"Git Question"},{"content":"Redis基本数据类型，应用场景 Redis的数据结构有:\n 字符串（String）：存储简单的数据，例如缓存某个简单的字符串、JSON格式的字符串、Redis分布式锁的实现、实现计数器、Session共享、分布式ID 哈希表（Hash）：存储一些key-value，适合用来存储对象 列表（List）：Redis的列表通过命令的组合，可当作栈或队列来使用，或是缓存一下消息数据流 集合（Set）：和列表类似，可存储多个不相同的元素，集合可以进行交集、并集、差集操作 有序集合（Sorted Set）：有序的Set 布隆过滤器（Bitmap） 坐标（GeoHash）：借助Sorted Set实现 HyperLogLog：统计不重复数据，用于大数据基数统计 Streams：内存版Kafka  常见的缓存淘汰算法  FIFO（First In First Out，先进先出），根据缓存被存储的时间，距离当前时间最远的数据优先被淘汰，类似于队列 LRU（Least Recently Used，最近最少使用）根据最近被使用的时间，距离当前时间最远的数据优先被淘汰 LFU（Least Frequently Used，最不经常使用），在一段时间内，缓存数据被使用次数最少的数据优先淘汰  Redis的持久化策略 RDB  Redis DataBase 将某一时刻的内存快照（Snapshot）以二进制的方式写入磁盘。\n 手动触发:\n save命令：使Redis处于阻塞状态，知道RDB持久化完成，才会响应其他客户端请求，所以在生产环境中谨慎使用 bgsave命令：fork出一个子进程执行持久化，主线程只在fork过程中又短暂的阻塞，子线程创建完成后，主线程才会响应其他客户端请求  自动触发:\n save m n: 在m秒内，如果有n个键发生改变，则自动触发持久化，通过调用bgsave执行，如果设置多个，只要满足其中一个就会触发一次。配置文件中有默认配置（可以注释掉） flushall: 用于清空Redis所有的数据库，flushdb清空当前Redis所在数据库，会清空RDB文件，同时会生成dump.rdb文件，内容为空  优点\n1、Redis数据库将只包含一个dump.rdb文件，方便持久化 2、容灾性好，方便备份\n3、性能最大化：fork子进程完成写操作，主进程继续处理请求。IO最大化：使用单独子线程进行持久化，主线程不会进行任何IO操作，保证了Redis的高性能\n4、相对于数据集大时，比AOF的启动效率更高\n缺点\n1、数据安全性低，持久化存在时间间隔，如果持久化之间Redis宕机，会发生数据丢失\n2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果数据集较大时，可能会导致服务器停止服务时间过长。占用cpu资源\n AOF  Append Only File 以日志的形式记录服务器所处理过的每一个写、删除操作，以文本的方式记录，打开文件可以看到详细的操作记录、调用操作系统命令进程刷盘\n 1、所有的写命令都会追加到AOF缓冲中\n2、AOF缓冲区根据对应的策略向硬盘进行同步操作\n3、AOF文件会越来越大，需要定期对AOF文件进行重写，达到压缩的目的\n4、当Redis重启时，可以加载AOF文件进行数据恢复\n同步策略:\n 每秒同步：异步完成，效率非常高，如果出现宕机现象，那么则会丢失这一秒钟之内修改的数据。 每修改同步：同步持久化，每次发生的数据变化都会被立即记录到磁盘中，最多丢失一条数据 不同步：有操作系统控制，可能会丢失较多数据  优点\n1、数据安全\n2、通过append模式写文件，即使服务器中途宕机也不会破坏已经存在的内容，可以通过redis-check-aof工具解决数据一致性问题\n3、AOF机制的rewrite模式。定期对AOF文件进行重写，以达到压缩文件的目的\n缺点\n1、AOF文件比RDB文件大，且恢复速度慢\n2、数据集大的时候，比RDB启动效率低\n3、运行效率比RDB低\n  ","permalink":"https://xiaotuanzijiang.github.io/posts/redis/","summary":"Redis基本数据类型，应用场景 Redis的数据结构有:\n 字符串（String）：存储简单的数据，例如缓存某个简单的字符串、JSON格式的字符串、Redis分布式锁的实现、实现计数器、Session共享、分布式ID 哈希表（Hash）：存储一些key-value，适合用来存储对象 列表（List）：Redis的列表通过命令的组合，可当作栈或队列来使用，或是缓存一下消息数据流 集合（Set）：和列表类似，可存储多个不相同的元素，集合可以进行交集、并集、差集操作 有序集合（Sorted Set）：有序的Set 布隆过滤器（Bitmap） 坐标（GeoHash）：借助Sorted Set实现 HyperLogLog：统计不重复数据，用于大数据基数统计 Streams：内存版Kafka  常见的缓存淘汰算法  FIFO（First In First Out，先进先出），根据缓存被存储的时间，距离当前时间最远的数据优先被淘汰，类似于队列 LRU（Least Recently Used，最近最少使用）根据最近被使用的时间，距离当前时间最远的数据优先被淘汰 LFU（Least Frequently Used，最不经常使用），在一段时间内，缓存数据被使用次数最少的数据优先淘汰  Redis的持久化策略 RDB  Redis DataBase 将某一时刻的内存快照（Snapshot）以二进制的方式写入磁盘。\n 手动触发:\n save命令：使Redis处于阻塞状态，知道RDB持久化完成，才会响应其他客户端请求，所以在生产环境中谨慎使用 bgsave命令：fork出一个子进程执行持久化，主线程只在fork过程中又短暂的阻塞，子线程创建完成后，主线程才会响应其他客户端请求  自动触发:\n save m n: 在m秒内，如果有n个键发生改变，则自动触发持久化，通过调用bgsave执行，如果设置多个，只要满足其中一个就会触发一次。配置文件中有默认配置（可以注释掉） flushall: 用于清空Redis所有的数据库，flushdb清空当前Redis所在数据库，会清空RDB文件，同时会生成dump.rdb文件，内容为空  优点\n1、Redis数据库将只包含一个dump.rdb文件，方便持久化 2、容灾性好，方便备份\n3、性能最大化：fork子进程完成写操作，主进程继续处理请求。IO最大化：使用单独子线程进行持久化，主线程不会进行任何IO操作，保证了Redis的高性能\n4、相对于数据集大时，比AOF的启动效率更高\n缺点\n1、数据安全性低，持久化存在时间间隔，如果持久化之间Redis宕机，会发生数据丢失\n2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果数据集较大时，可能会导致服务器停止服务时间过长。占用cpu资源\n AOF  Append Only File 以日志的形式记录服务器所处理过的每一个写、删除操作，以文本的方式记录，打开文件可以看到详细的操作记录、调用操作系统命令进程刷盘\n 1、所有的写命令都会追加到AOF缓冲中\n2、AOF缓冲区根据对应的策略向硬盘进行同步操作\n3、AOF文件会越来越大，需要定期对AOF文件进行重写，达到压缩的目的\n4、当Redis重启时，可以加载AOF文件进行数据恢复\n同步策略:","title":"Redis面试题"},{"content":"前端 - Color - CSSLayout - CSSGridGenerator - Uigradients - FreeDownloads 后端 - Binary Tree - BinaryTreeVisuakuser - Data Structure Visualizations - MvnRepository - MavenRepository - 阿里巴巴开源镜像站 其他 - MarkDown编辑器 - Eclipse主题 - Pexels - CodeLf - Favicon - RegexLearn  \r","permalink":"https://xiaotuanzijiang.github.io/posts/unitl/","summary":"前端 - Color - CSSLayout - CSSGridGenerator - Uigradients - FreeDownloads 后端 - Binary Tree - BinaryTreeVisuakuser - Data Structure Visualizations - MvnRepository - MavenRepository - 阿里巴巴开源镜像站 其他 - MarkDown编辑器 - Eclipse主题 - Pexels - CodeLf - Favicon - RegexLearn  \r","title":"UNTIL"}]