[{"content":"Redis基本数据类型，应用场景 Redis的数据结构有:\n 字符串（String）：存储简单的数据，例如缓存某个简单的字符串、JSON格式的字符串、Redis分布式锁的实现、实现计数器、Session共享、分布式ID 哈希表（Hash）：存储一些key-value，适合用来存储对象 列表（List）：Redis的列表通过命令的组合，可当作栈或队列来使用，或是缓存一下消息数据流 集合（Set）：和列表类似，可存储多个不相同的元素，集合可以进行交集、并集、差集操作 有序集合（Sorted Set）：有序的Set 布隆过滤器（Bitmap） 坐标（GeoHash）：借助Sorted Set实现 HyperLogLog：统计不重复数据，用于大数据基数统计 Streams：内存版Kafka  常见的缓存淘汰算法  FIFO（First In First Out，先进先出），根据缓存被存储的时间，距离当前时间最远的数据优先被淘汰，类似于队列 LRU（Least Recently Used，最近最少使用）根据最近被使用的时间，距离当前时间最远的数据优先被淘汰 LFU（Least Frequently Used，最不经常使用），在一段时间内，缓存数据被使用次数最少的数据优先淘汰  Redis的持久化策略 RDB  Redis DataBase 将某一时刻的内存快照（Snapshot）以二进制的方式写入磁盘。\n 手动触发:\n save命令：使Redis处于阻塞状态，知道RDB持久化完成，才会响应其他客户端请求，所以在生产环境中谨慎使用 bgsave命令：fork出一个子进程执行持久化，主线程只在fork过程中又短暂的阻塞，子线程创建完成后，主线程才会响应其他客户端请求  自动触发:\n save m n: 在m秒内，如果有n个键发生改变，则自动触发持久化，通过调用bgsave执行，如果设置多个，只要满足其中一个就会触发一次。配置文件中有默认配置（可以注释掉） flushall: 用于清空Redis所有的数据库，flushdb清空当前Redis所在数据库，会清空RDB文件，同时会生成dump.rdb文件，内容为空  优点\n1、Redis数据库将只包含一个dump.rdb文件，方便持久化 2、容灾性好，方便备份\n3、性能最大化：fork子进程完成写操作，主进程继续处理请求。IO最大化：使用单独子线程进行持久化，主线程不会进行任何IO操作，保证了Redis的高性能\n4、相对于数据集大时，比AOF的启动效率更高\n缺点\n1、数据安全性低，持久化存在时间间隔，如果持久化之间Redis宕机，会发生数据丢失\n2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果数据集较大时，可能会导致服务器停止服务时间过长。占用cpu资源\n AOF  Append Only File 以日志的形式记录服务器所处理过的每一个写、删除操作，以文本的方式记录，打开文件可以看到详细的操作记录、调用操作系统命令进程刷盘\n 1、所有的写命令都会追加到AOF缓冲中\n2、AOF缓冲区根据对应的策略向硬盘进行同步操作\n3、AOF文件会越来越大，需要定期对AOF文件进行重写，达到压缩的目的\n4、当Redis重启时，可以加载AOF文件进行数据恢复\n同步策略:\n 每秒同步：异步完成，效率非常高，如果出现宕机现象，那么则会丢失这一秒钟之内修改的数据。 每修改同步：同步持久化，每次发生的数据变化都会被立即记录到磁盘中，最多丢失一条数据 不同步：有操作系统控制，可能会丢失较多数据  优点\n1、数据安全\n2、通过append模式写文件，即使服务器中途宕机也不会破坏已经存在的内容，可以通过redis-check-aof工具解决数据一致性问题\n3、AOF机制的rewrite模式。定期对AOF文件进行重写，以达到压缩文件的目的\n缺点\n1、AOF文件比RDB文件大，且恢复速度慢\n2、数据集大的时候，比RDB启动效率低\n3、运行效率比RDB低\n  ","permalink":"https://xiaotuanzijiang.github.io/posts/redis/","summary":"Redis基本数据类型，应用场景 Redis的数据结构有:\n 字符串（String）：存储简单的数据，例如缓存某个简单的字符串、JSON格式的字符串、Redis分布式锁的实现、实现计数器、Session共享、分布式ID 哈希表（Hash）：存储一些key-value，适合用来存储对象 列表（List）：Redis的列表通过命令的组合，可当作栈或队列来使用，或是缓存一下消息数据流 集合（Set）：和列表类似，可存储多个不相同的元素，集合可以进行交集、并集、差集操作 有序集合（Sorted Set）：有序的Set 布隆过滤器（Bitmap） 坐标（GeoHash）：借助Sorted Set实现 HyperLogLog：统计不重复数据，用于大数据基数统计 Streams：内存版Kafka  常见的缓存淘汰算法  FIFO（First In First Out，先进先出），根据缓存被存储的时间，距离当前时间最远的数据优先被淘汰，类似于队列 LRU（Least Recently Used，最近最少使用）根据最近被使用的时间，距离当前时间最远的数据优先被淘汰 LFU（Least Frequently Used，最不经常使用），在一段时间内，缓存数据被使用次数最少的数据优先淘汰  Redis的持久化策略 RDB  Redis DataBase 将某一时刻的内存快照（Snapshot）以二进制的方式写入磁盘。\n 手动触发:\n save命令：使Redis处于阻塞状态，知道RDB持久化完成，才会响应其他客户端请求，所以在生产环境中谨慎使用 bgsave命令：fork出一个子进程执行持久化，主线程只在fork过程中又短暂的阻塞，子线程创建完成后，主线程才会响应其他客户端请求  自动触发:\n save m n: 在m秒内，如果有n个键发生改变，则自动触发持久化，通过调用bgsave执行，如果设置多个，只要满足其中一个就会触发一次。配置文件中有默认配置（可以注释掉） flushall: 用于清空Redis所有的数据库，flushdb清空当前Redis所在数据库，会清空RDB文件，同时会生成dump.rdb文件，内容为空  优点\n1、Redis数据库将只包含一个dump.rdb文件，方便持久化 2、容灾性好，方便备份\n3、性能最大化：fork子进程完成写操作，主进程继续处理请求。IO最大化：使用单独子线程进行持久化，主线程不会进行任何IO操作，保证了Redis的高性能\n4、相对于数据集大时，比AOF的启动效率更高\n缺点\n1、数据安全性低，持久化存在时间间隔，如果持久化之间Redis宕机，会发生数据丢失\n2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果数据集较大时，可能会导致服务器停止服务时间过长。占用cpu资源\n AOF  Append Only File 以日志的形式记录服务器所处理过的每一个写、删除操作，以文本的方式记录，打开文件可以看到详细的操作记录、调用操作系统命令进程刷盘\n 1、所有的写命令都会追加到AOF缓冲中\n2、AOF缓冲区根据对应的策略向硬盘进行同步操作\n3、AOF文件会越来越大，需要定期对AOF文件进行重写，达到压缩的目的\n4、当Redis重启时，可以加载AOF文件进行数据恢复\n同步策略:","title":"Redis面试题"},{"content":"1. 创建一个新的分支：  git branch newBranch\n 2. 查看分支是否创建成功：  git branch\n 3. 切换到新分区：  git checkout newBranch\n 4. 把代码直接提到newBranch分支上,如果出现提示,直接执行：  git push \u0026ndash;set-upstream origin newBranch\n 5. 切换回本想要提交代码的分区,把newBranch合并到 master分支上：  git checkout master\ngit merge newBranch\n 6. 删除新分区：  git branch -D newBranch\n 7. 重新提交一下代码：  git push\n  \r","permalink":"https://xiaotuanzijiang.github.io/posts/git%E9%97%AE%E9%A2%98/","summary":"1. 创建一个新的分支：  git branch newBranch\n 2. 查看分支是否创建成功：  git branch\n 3. 切换到新分区：  git checkout newBranch\n 4. 把代码直接提到newBranch分支上,如果出现提示,直接执行：  git push \u0026ndash;set-upstream origin newBranch\n 5. 切换回本想要提交代码的分区,把newBranch合并到 master分支上：  git checkout master\ngit merge newBranch\n 6. 删除新分区：  git branch -D newBranch\n 7. 重新提交一下代码：  git push\n  \r","title":"Git提交代码时出现Everything up-to-date"},{"content":"前端 - Color - CSSLayout - CSSGridGenerator - Uigradients - FreeDownloads 后端 - Binary Tree - BinaryTreeVisuakuser - Data Structure Visualizations - MvnRepository - MavenRepository - 阿里巴巴开源镜像站 其他 - MarkDown编辑器 - Eclipse主题 - Pexels - CodeLf - Favicon - RegexLearn  \r","permalink":"https://xiaotuanzijiang.github.io/posts/unitl/","summary":"前端 - Color - CSSLayout - CSSGridGenerator - Uigradients - FreeDownloads 后端 - Binary Tree - BinaryTreeVisuakuser - Data Structure Visualizations - MvnRepository - MavenRepository - 阿里巴巴开源镜像站 其他 - MarkDown编辑器 - Eclipse主题 - Pexels - CodeLf - Favicon - RegexLearn  \r","title":"UNTIL"},{"content":"LeetCode_每日一题 2.20-717. 1比特与2比特字符 难度：简单\n 模拟\n class Solution { public boolean isOneBitCharacter(int[] bits) { int n = bits.length, i = 0; while(i \u0026lt; n - 1){ if(bits[i] == 0) i++; else i += 2; } return i == n - 1; } } 2.18-791. 找出星型图的中心节点 难度：简单\n HashMap\n class Solution { public int findCenter (int[][] edges) { HashMap\u0026lt;Integer, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); int res = 0; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 2; j++) { if (hashMap.containsKey(edges[i][j])) { res = edges[i][j]; } hashMap.put(edges[i][j], 0); } } return res; } }  模拟\n class Solution { public int findCenter(int[][] edges) { return edges[0][0] == edges[1][0] ? edges[1][0] : edges[0][0] == edges[1][1] ? edges[1][1] : edges[0][1] == edges[1][0] ? edges[1][0] : edges[1][1]; } } 2.15-1380. 矩阵中的幸运数 难度：简单\n 模拟\n class Solution { public List\u0026lt;Integer\u0026gt; luckyNumbers (int[][] matrix) { List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int m = matrix.length, n = matrix[0].length; int[] row = new int[m]; int[] col = new int[n]; for(int i = 0; i \u0026lt; m; i++){ row[i] = Integer.MAX_VALUE; for(int j = 0; j \u0026lt; n; j++){ row[i] = Math.min(matrix[i][j],row[i]); col[j] = Math.max(matrix[i][j],col[j]); } } for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (matrix[i][j] == row[i] \u0026amp;\u0026amp; matrix[i][j] == col[j]) { ans.add(matrix[i][j]); return ans; } } } return ans; } } 2.14-540. 有序数组中的单一元素 难度：中等\n 二分\n class Solution { public int singleNonDuplicate(int[] nums) { int n = nums.length; int l = 0,r = n - 1; while(l \u0026lt; r){ int mid = (l + r) \u0026gt;\u0026gt; 1; if((mid \u0026amp; 1) == 0){ if (mid + 1 \u0026lt; n \u0026amp;\u0026amp; nums[mid] == nums[mid + 1]) l = mid + 1; else r = mid; }else{ if (mid - 1 \u0026gt;= 0 \u0026amp;\u0026amp; nums[mid - 1] == nums[mid]) l = mid + 1; else r = mid; } } return nums[r]; } } 2.11-1984. 学生分数的最小差值 难度：简单\n 排序+动态窗口\n class Solution { public int minimumDifference(int[] nums, int k) { Arrays.sort(nums); int ans = Integer.MAX_VALUE; for (int i = 0; i \u0026lt;= nums.length - k; i++) { ans = Math.min(ans, nums[i + k - 1] - nums[i]); } return ans; } } 2.4-1725. 可以形成最大正方形的矩形数目 难度：简单\n 模拟\n class Solution { public int countGoodRectangles(int[][] rectangles) { int max = 0, ans = 0; for (int[] r : rectangles) { int cur = Math.min(r[0], r[1]); if (cur == max) ans++; else if (cur \u0026gt; max) { max = cur; ans = 1; } } return ans; } } 2.2-2000. 反转单词前缀 难度：简单\n 模拟\n class Solution { public String reversePrefix(String word, char ch) { StringBuilder sb = new StringBuilder(); char[] cs = word.toCharArray(); boolean isone = true; for (int i = 0; i \u0026lt; cs.length; i++) { sb.append(cs[i]); if(cs[i] == ch \u0026amp;\u0026amp; isone){ isone = false; sb.reverse(); } } return sb.toString(); } } 1.31-1342. 将数字变成 0 的操作次数 难度：简单\n 模拟\n class Solution { public int numberOfSteps(int num) { int con = 0; while (num != 0) { num = (num \u0026amp; 1) == 0 ? num \u0026gt;\u0026gt; 1 : num - 1; con++; } return con; } } 1.30-884. 两句话中的不常见单词 难度：简单\n HashMap\n class Solution { public String[] uncommonFromSentences(String s1, String s2) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); count(s1, map); count(s2, map); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); map.forEach((k, v) -\u0026gt; { if (v == 1) { list.add(k); } }); return list.toArray(new String[list.size()]); } private void count(String s, Map\u0026lt;String, Integer\u0026gt; map) { for (String a : s.split(\u0026#34; \u0026#34;)) { map.put(a, map.getOrDefault(a, 0) + 1); } } } 1.28-1996. 游戏中弱角色的数量 难度：中等\n 排序\n class Solution { public int numberOfWeakCharacters(int[][] properties) { Arrays.sort(properties,(a,b)-\u0026gt;{ return a[0] == b[0] ? (a[1] - b[1]) : (b[0] - a[0]); }); int cnt = 0; int temp = 0; for (int[] p : properties) { if(p[1] \u0026lt; temp) cnt++; else temp = p[1]; } return cnt; } } 1.27-2047. 句子中的有效单词数 难度：简单\n 模拟\n class Solution { public int countValidWords(String sentence) { String[] ss = sentence.split(\u0026#34; \u0026#34;); int ans = 0; for (String s : ss) if (check(s)) ans++; return ans; } boolean check(String s) { int n = s.length(); if (n == 0) return false; for (int i = 0, c1 = 0, c2 = 0; i \u0026lt; n; i++) { char c = s.charAt(i); if (Character.isDigit(c)) return false; if (c == \u0026#39; \u0026#39;) return false; if (c == \u0026#39;-\u0026#39; \u0026amp;\u0026amp; ++c1 \u0026gt;= 0) { if (c1 \u0026gt; 1 || (i == 0 || i == n - 1)) return false; if (!Character.isLetter(s.charAt(i - 1)) || !Character.isLetter(s.charAt(i + 1))) return false; } if ((c == \u0026#39;!\u0026#39; || c == \u0026#39;.\u0026#39; || c == \u0026#39;,\u0026#39;) \u0026amp;\u0026amp; ++c2 \u0026gt;= 0) { if (c2 \u0026gt; 1 || (i != n - 1)) return false; } } return true; } } 1.25-1688. 比赛中的配对次数 难度：简单\n 脑筋急转弯\n class Solution { public int numberOfMatches(int n) { return n - 1; } } 1.22-1332. 删除回文子序列 难度：简单\n 模拟\n class Solution { public int removePalindromeSub(String s) { int n = s.length(); for(int i = 0; i \u0026lt; (n \u0026gt;\u0026gt; 1); i++) if(s.charAt(i) != s.charAt(n-1-i)) return 2; return 1; } } 1.19-219.存在重复元素II 难度：简单\n HashMap\n class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { HashMap\u0026lt;Integer, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; nums.length; i++) { int num = nums[i]; if(hashMap.containsKey(num)) { return true; } hashMap.put(num, null); if(hashMap.size() \u0026gt; k) { hashMap.remove(nums[i - k]); } } return false; } } LeetCode_周赛 第 276 场周赛 2138. 将字符串拆分为若干长度为 k 的组 难度：简单\n 补全分割\n class Solution { public String[] divideString(String s, int k, char fill) { int num = s.length() % k; if(num != 0) { num = k - num; while(num-- \u0026gt; 0) { s += fill; } } int len = s.length() / k; String[] ans = new String[len]; for(int i = 0; i \u0026lt; len; i++) { ans[i] = s.substring(i*k, (i + 1) * k); } return ans; } } 2139. 得到目标值的最少行动次数 难度：中等\n 贪心\n class Solution { public int minMoves(int target, int maxDoubles) { int cnt = 0; while(target \u0026gt; 1) { if(maxDoubles \u0026gt; 0) { if((target \u0026amp; 1) == 1) target--; else { target \u0026gt;\u0026gt;= 1; maxDoubles--; } cnt++; }else { return target + cnt - 1; } } return cnt; } } 2140. 解决智力问题 难度：中等\n 逆序dp\n class Solution { public long mostPoints(int[][] questions) { int n = questions.length; long[] dp = new long[n + 1]; for(int i = n -1; i \u0026gt;= 0; i--) { if(questions[i][1] + i + 1 \u0026lt; n) { dp[i] = Math.max(dp[i + 1], dp[questions[i][1] + i + 1] + questions[i][0]); } else { dp[i] = Math.max(dp[i + 1], questions[i][0]); } } return dp[0]; } } 第 275 场周赛 2133. 检查是否每一行每一列都包含全部整数 难度：简单\n HashSet\n class Solution { public boolean checkValid(int[][] matrix) { int len = matrix.length; HashSet\u0026lt;Integer\u0026gt; h1 = new HashSet\u0026lt;\u0026gt;(); HashSet\u0026lt;Integer\u0026gt; h2 = new HashSet\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; len; i++) { for(int j = 0; j \u0026lt; len; j++) { h1.add(matrix[i][j]); h2.add(matrix[j][i]); } if(h1.size() != len || h2.size() != len) return false; h1.clear(); h2.clear(); } return true; } } 第 69 场双周赛 2129. 将标题首字母大写 难度：简单\n Api+Ascii\n class Solution { public String capitalizeTitle(String title) { String[] str = title.split(\u0026#34; \u0026#34;); for(int i = 0; i \u0026lt; str.length; i++) { if(str[i].length() \u0026lt; 3) { str[i] = str[i].toLowerCase(); } else { char[] c = str[i].toLowerCase().toCharArray(); c[0] \u0026amp;= ~32; str[i] = String.valueOf(c); } } return String.join(\u0026#34; \u0026#34;, str); } } 2130. 链表最大孪生和 难度：中等\n 链表转数组+双指针\n class Solution { public int pairSum(ListNode head) { if(head.next == null) return 0; List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); while(head != null) { list.add(head.val); head = head.next; } Integer[] num = list.toArray(new Integer[0]); int mid = num.length \u0026gt;\u0026gt; 1; int max = 0; for(int i = mid - 1; i \u0026gt;= 0; i--){ max = Math.max(max, num[i] + num[mid++]); } return max; } } 第 274 场周赛 2124. 检查是否所有 A 都在 B 之前 难度：简单\n 标记\n class Solution { public boolean checkString(String s) { char[] cs = s.toCharArray(); boolean na = false; for(char c : cs) { if(c == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; na) return false; if(c != \u0026#39;a\u0026#39;) na = true; } return true; } } 2125. 银行中的激光束数量 难度：中等\n cnt * pre\n class Solution { public int numberOfBeams(String[] bank) { int ans = 0; int pre = 0; for(String s : bank) { int cnt = 0; char[] cs = s.toCharArray(); for(int i = 0; i \u0026lt; cs.length; i++) { cnt += cs[i] == \u0026#39;1\u0026#39; ? 1 : 0; } if(cnt != 0) { ans += cnt * pre; pre = cnt; } } return ans; } } 2126. 摧毁小行星 难度：中等\n 排序+贪心\n class Solution { public boolean asteroidsDestroyed(int mass, int[] asteroids) { long mas = mass; Arrays.sort(asteroids); for(int i : asteroids) { if(mas \u0026lt; i) return false; mas += i; } return true; } } 第 273 场周赛 2119. 反转两次的数字 难度：简单\n 末尾不为0\n class Solution { public boolean isSameAfterReversals(int num) { return !(num != 0 \u0026amp;\u0026amp; num % 10 == 0); } } LeetCode_Other 169. 多数元素 难度：简单\n 脑筋急转弯\n class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length \u0026gt;\u0026gt; 1]; } }  摩尔投票法\n class Solution { public int majorityElement(int[] nums) { int cnt = 0; int temp = 0; for(int i : nums) { if(cnt == 0) { temp = i; cnt = 1; }else { cnt += temp != i ? -1 : 1; } } return temp; } }  \r","permalink":"https://xiaotuanzijiang.github.io/posts/leetcode/","summary":"LeetCode_每日一题 2.20-717. 1比特与2比特字符 难度：简单\n 模拟\n class Solution { public boolean isOneBitCharacter(int[] bits) { int n = bits.length, i = 0; while(i \u0026lt; n - 1){ if(bits[i] == 0) i++; else i += 2; } return i == n - 1; } } 2.18-791. 找出星型图的中心节点 难度：简单\n HashMap\n class Solution { public int findCenter (int[][] edges) { HashMap\u0026lt;Integer, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); int res = 0; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 2; j++) { if (hashMap.","title":"LeetCode"}]