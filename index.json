[{"content":"线程概述 线程相关概念 进程: 是操作系统进行资源分配和调度的基本单位,可以简单理解为正在操作系统中云心的一个程序 线程: 线程是进程的一个执行单元 主线程与子线程 主线程就是运行main方法的线程 如果在A线程中创建了B线程，那么B线程就是A线程的子线程 串行、并发和并行 串行可以理解为单通道，进程一个一个执行 并发可以理解为多通道，多个进程一起执行 并行是一种更为严格、理想的并发，多个进程同一时间点执行 线程的创建与启动 在Java中，创建一个线程就是创建一个Thread类(子类)的对象(实例) 1、定义Thread类的子类 2、定义一个Runnable接口的实现类  两种创建方法没有本质的区别\n 启动: Thread.start( ); 线程的常用方法 Thread.currentThread( ) \u0026ndash;\u0026gt; 获得当前线程  return: Thread\n Thread.setName(name)/getName( ) \u0026ndash;\u0026gt; 设置线程名称，返回线程名称 Thread.isAlive( ) \u0026ndash;\u0026gt; 判断当前线程是否处于活动状态 Thread.sleep(millis) \u0026ndash;\u0026gt; 指定当前线程休眠的毫秒数 Thread.getId( ) \u0026ndash;\u0026gt; 获得线程的唯一标识 Thread.yieId( ) \u0026ndash;\u0026gt; 使当前线程放弃CPU资源 Thread.setPriority(num) \u0026ndash;\u0026gt; 设置线程优先级  1\u0026lt;=num\u0026lt;=10 超出范围抛出 IllegalArgumentException\n线程优先级本质只是给线程调度器一个提示信息，不能保证优先级高的线程先运行，开发时不必设置线程优先级\n线程优先级具有继承性\n Thread.interrupt( ) \u0026ndash;\u0026gt; 中断线程  仅仅是在当前线程设置停止标志，并不会真正停止线程\n Thread.setDaemon( ) \u0026ndash;\u0026gt; 设置当前线程为守护线程  Java中的线程分为用户线程与守护线程\n守护线程是为其他线程提供服务的线程，例如垃圾回收器(GC)\n守护线程不能单独运行，当JVM中没有其他用户线程，只有守护线程，JVM会退出\n 线程的生命周期 ","permalink":"https://xiaotuanzijiang.github.io/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","summary":"线程概述 线程相关概念 进程: 是操作系统进行资源分配和调度的基本单位,可以简单理解为正在操作系统中云心的一个程序 线程: 线程是进程的一个执行单元 主线程与子线程 主线程就是运行main方法的线程 如果在A线程中创建了B线程，那么B线程就是A线程的子线程 串行、并发和并行 串行可以理解为单通道，进程一个一个执行 并发可以理解为多通道，多个进程一起执行 并行是一种更为严格、理想的并发，多个进程同一时间点执行 线程的创建与启动 在Java中，创建一个线程就是创建一个Thread类(子类)的对象(实例) 1、定义Thread类的子类 2、定义一个Runnable接口的实现类  两种创建方法没有本质的区别\n 启动: Thread.start( ); 线程的常用方法 Thread.currentThread( ) \u0026ndash;\u0026gt; 获得当前线程  return: Thread\n Thread.setName(name)/getName( ) \u0026ndash;\u0026gt; 设置线程名称，返回线程名称 Thread.isAlive( ) \u0026ndash;\u0026gt; 判断当前线程是否处于活动状态 Thread.sleep(millis) \u0026ndash;\u0026gt; 指定当前线程休眠的毫秒数 Thread.getId( ) \u0026ndash;\u0026gt; 获得线程的唯一标识 Thread.yieId( ) \u0026ndash;\u0026gt; 使当前线程放弃CPU资源 Thread.setPriority(num) \u0026ndash;\u0026gt; 设置线程优先级  1\u0026lt;=num\u0026lt;=10 超出范围抛出 IllegalArgumentException\n线程优先级本质只是给线程调度器一个提示信息，不能保证优先级高的线程先运行，开发时不必设置线程优先级\n线程优先级具有继承性\n Thread.interrupt( ) \u0026ndash;\u0026gt; 中断线程  仅仅是在当前线程设置停止标志，并不会真正停止线程\n Thread.setDaemon( ) \u0026ndash;\u0026gt; 设置当前线程为守护线程  Java中的线程分为用户线程与守护线程","title":"Java多线程"},{"content":"1. 创建一个新的分支：  git branch newBranch\n 2. 查看分支是否创建成功：  git branch\n 3. 切换到新分区：  git checkout newBranch\n 4. 把代码直接提到newBranch分支上,如果出现提示,直接执行：  git push \u0026ndash;set-upstream origin newBranch\n 5. 切换回本想要提交代码的分区,把newBranch合并到 master分支上：  git checkout master\ngit merge newBranch\n 6. 删除新分区：  git branch -D newBranch\n 7. 重新提交一下代码：  git push\n ","permalink":"https://xiaotuanzijiang.github.io/posts/git%E9%97%AE%E9%A2%98/","summary":"1. 创建一个新的分支：  git branch newBranch\n 2. 查看分支是否创建成功：  git branch\n 3. 切换到新分区：  git checkout newBranch\n 4. 把代码直接提到newBranch分支上,如果出现提示,直接执行：  git push \u0026ndash;set-upstream origin newBranch\n 5. 切换回本想要提交代码的分区,把newBranch合并到 master分支上：  git checkout master\ngit merge newBranch\n 6. 删除新分区：  git branch -D newBranch\n 7. 重新提交一下代码：  git push\n ","title":"Git提交代码时出现Everything up-to-date"},{"content":"前端 - Color - CSSLayout - CSSGridGenerator - Uigradients - FreeDownloads 后端 - Binary Tree - BinaryTreeVisuakuser - Data Structure Visualizations - MvnRepository - MavenRepository - 阿里巴巴开源镜像站 其他 - MarkDown编辑器 - Eclipse主题 - Pexels - CodeLf - Favicon - RegexLearn ","permalink":"https://xiaotuanzijiang.github.io/posts/unitl/","summary":"前端 - Color - CSSLayout - CSSGridGenerator - Uigradients - FreeDownloads 后端 - Binary Tree - BinaryTreeVisuakuser - Data Structure Visualizations - MvnRepository - MavenRepository - 阿里巴巴开源镜像站 其他 - MarkDown编辑器 - Eclipse主题 - Pexels - CodeLf - Favicon - RegexLearn ","title":"UNTIL"},{"content":"LeetCode_每日一题 1.25-1688. 比赛中的配对次数 难度：简单\n 脑筋急转弯\n class Solution {\rpublic int numberOfMatches(int n) {\rreturn n - 1;\r}\r}\r 1.22-1332. 删除回文子序列 难度：简单\n 模拟\n class Solution {\rpublic int removePalindromeSub(String s) {\rint n = s.length();\rfor(int i = 0; i \u0026lt; (n \u0026gt;\u0026gt; 1); i++)\rif(s.charAt(i) != s.charAt(n-1-i)) return 2;\rreturn 1;\r}\r}\r 1.19-219.存在重复元素II 难度：简单\n HashMap\n class Solution {\rpublic boolean containsNearbyDuplicate(int[] nums, int k) {\rHashMap\u0026lt;Integer, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;();\rfor(int i = 0; i \u0026lt; nums.length; i++) {\rint num = nums[i];\rif(hashMap.containsKey(num)) {\rreturn true;\r}\rhashMap.put(num, null);\rif(hashMap.size() \u0026gt; k) {\rhashMap.remove(nums[i - k]);\r}\r}\rreturn false;\r}\r}\r LeetCode_周赛 第 276 场周赛 2138. 将字符串拆分为若干长度为 k 的组 难度：简单\n 补全分割\n class Solution {\rpublic String[] divideString(String s, int k, char fill) {\rint num = s.length() % k;\rif(num != 0) {\rnum = k - num;\rwhile(num-- \u0026gt; 0) {\rs += fill;\r}\r}\rint len = s.length() / k;\rString[] ans = new String[len];\rfor(int i = 0; i \u0026lt; len; i++) {\rans[i] = s.substring(i*k, (i + 1) * k);\r}\rreturn ans;\r}\r}\r 2139. 得到目标值的最少行动次数 难度：中等\n 贪心\n class Solution {\rpublic int minMoves(int target, int maxDoubles) {\rint cnt = 0;\rwhile(target \u0026gt; 1) {\rif(maxDoubles \u0026gt; 0) {\rif((target \u0026amp; 1) == 1) target--;\relse {\rtarget \u0026gt;\u0026gt;= 1;\rmaxDoubles--;\r}\rcnt++;\r}else {\rreturn target + cnt - 1;\r}\r}\rreturn cnt;\r}\r}\r 2140. 解决智力问题 难度：中等\n 逆序dp\n class Solution {\rpublic long mostPoints(int[][] questions) {\rint n = questions.length;\rlong[] dp = new long[n + 1];\rfor(int i = n -1; i \u0026gt;= 0; i--) {\rif(questions[i][1] + i + 1 \u0026lt; n) {\rdp[i] = Math.max(dp[i + 1], dp[questions[i][1] + i + 1] + questions[i][0]);\r} else {\rdp[i] = Math.max(dp[i + 1], questions[i][0]);\r}\r}\rreturn dp[0];\r}\r}  第 275 场周赛 2133. 检查是否每一行每一列都包含全部整数 难度：简单\n HashSet\n class Solution {\rpublic boolean checkValid(int[][] matrix) {\rint len = matrix.length;\rHashSet\u0026lt;Integer\u0026gt; h1 = new HashSet\u0026lt;\u0026gt;();\rHashSet\u0026lt;Integer\u0026gt; h2 = new HashSet\u0026lt;\u0026gt;();\rfor(int i = 0; i \u0026lt; len; i++) {\rfor(int j = 0; j \u0026lt; len; j++) {\rh1.add(matrix[i][j]);\rh2.add(matrix[j][i]);\r}\rif(h1.size() != len || h2.size() != len) return false;\rh1.clear();\rh2.clear();\r}\rreturn true;\r}\r}\t 第 69 场双周赛 2129. 将标题首字母大写 难度：简单\n Api+Ascii\n class Solution {\rpublic String capitalizeTitle(String title) {\rString[] str = title.split(\u0026quot; \u0026quot;);\rfor(int i = 0; i \u0026lt; str.length; i++) {\rif(str[i].length() \u0026lt; 3) {\rstr[i] = str[i].toLowerCase();\r} else {\rchar[] c = str[i].toLowerCase().toCharArray();\rc[0] \u0026amp;= ~32;\rstr[i] = String.valueOf(c);\r}\r}\rreturn String.join(\u0026quot; \u0026quot;, str);\r}\r}\r 2130. 链表最大孪生和 难度：中等\n 链表转数组+双指针\n class Solution {\rpublic int pairSum(ListNode head) {\rif(head.next == null) return 0;\rList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;();\rwhile(head != null) {\rlist.add(head.val);\rhead = head.next;\r}\rInteger[] num = list.toArray(new Integer[0]);\rint mid = num.length \u0026gt;\u0026gt; 1;\rint max = 0;\rfor(int i = mid - 1; i \u0026gt;= 0; i--){\rmax = Math.max(max, num[i] + num[mid++]);\r}\rreturn max;\r}\r}\r 第 274 场周赛 2124. 检查是否所有 A 都在 B 之前 难度：简单\n 标记\n class Solution {\rpublic boolean checkString(String s) {\rchar[] cs = s.toCharArray();\rboolean na = false;\rfor(char c : cs) {\rif(c == 'a' \u0026amp;\u0026amp; na) return false;\rif(c != 'a') na = true;\r}\rreturn true;\r}\r}\r 2125. 银行中的激光束数量 难度：中等\n cnt * pre\n class Solution {\rpublic int numberOfBeams(String[] bank) {\rint ans = 0;\rint pre = 0;\rfor(String s : bank) {\rint cnt = 0;\rchar[] cs = s.toCharArray();\rfor(int i = 0; i \u0026lt; cs.length; i++) {\rcnt += cs[i] == '1' ? 1 : 0;\r}\rif(cnt != 0) {\rans += cnt * pre;\rpre = cnt;\r}\r}\rreturn ans;\r}\r}\r 2126. 摧毁小行星 难度：中等\n 排序+贪心\n class Solution {\rpublic boolean asteroidsDestroyed(int mass, int[] asteroids) {\rlong mas = mass;\rArrays.sort(asteroids);\rfor(int i : asteroids) {\rif(mas \u0026lt; i) return false;\rmas += i;\r}\rreturn true;\r}\r}\r 第 273 场周赛 2119. 反转两次的数字 难度：简单\n 末尾不为0\n class Solution {\rpublic boolean isSameAfterReversals(int num) {\rreturn !(num != 0 \u0026amp;\u0026amp; num % 10 == 0);\r}\r}\r LeetCode_Other 169. 多数元素 难度：简单\n 脑筋急转弯\n class Solution {\rpublic int majorityElement(int[] nums) {\rArrays.sort(nums);\rreturn nums[nums.length \u0026gt;\u0026gt; 1];\r}\r}\r  摩尔投票法\n class Solution {\rpublic int majorityElement(int[] nums) {\rint cnt = 0;\rint temp = 0;\rfor(int i : nums) {\rif(cnt == 0) {\rtemp = i;\rcnt = 1;\r}else {\rcnt += temp != i ? -1 : 1;\r}\r}\rreturn temp;\r}\r} ","permalink":"https://xiaotuanzijiang.github.io/posts/leetcode/","summary":"LeetCode_每日一题 1.25-1688. 比赛中的配对次数 难度：简单\n 脑筋急转弯\n class Solution {\rpublic int numberOfMatches(int n) {\rreturn n - 1;\r}\r}\r 1.22-1332. 删除回文子序列 难度：简单\n 模拟\n class Solution {\rpublic int removePalindromeSub(String s) {\rint n = s.length();\rfor(int i = 0; i \u0026lt; (n \u0026gt;\u0026gt; 1); i++)\rif(s.charAt(i) != s.charAt(n-1-i)) return 2;\rreturn 1;\r}\r}\r 1.19-219.存在重复元素II 难度：简单\n HashMap\n class Solution {\rpublic boolean containsNearbyDuplicate(int[] nums, int k) {\rHashMap\u0026lt;Integer, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;();\rfor(int i = 0; i \u0026lt; nums.","title":"LeetCode"}]