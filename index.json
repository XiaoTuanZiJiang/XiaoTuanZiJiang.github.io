[{"content":"第 276 场周赛 2138. 将字符串拆分为若干长度为 k 的组 难度：简单\nclass Solution {\rpublic String[] divideString(String s, int k, char fill) {\rint num = s.length() % k;\rif(num != 0) {\rnum = k - num;\rwhile(num-- \u0026gt; 0) {\rs += fill;\r}\r}\rint len = s.length() / k;\rString[] ans = new String[len];\rfor(int i = 0; i \u0026lt; len; i++) {\rans[i] = s.substring(i*k, (i + 1) * k);\r}\rreturn ans;\r}\r} ","permalink":"https://xiaotuanzijiang.github.io/posts/leetcode_%E5%91%A8%E8%B5%9B/","summary":"第 276 场周赛 2138. 将字符串拆分为若干长度为 k 的组 难度：简单\nclass Solution {\rpublic String[] divideString(String s, int k, char fill) {\rint num = s.length() % k;\rif(num != 0) {\rnum = k - num;\rwhile(num-- \u0026gt; 0) {\rs += fill;\r}\r}\rint len = s.length() / k;\rString[] ans = new String[len];\rfor(int i = 0; i \u0026lt; len; i++) {\rans[i] = s.substring(i*k, (i + 1) * k);\r}\rreturn ans;\r}\r} ","title":"LeetCode_周赛"},{"content":"1.19_LeetCode-219.存在重复元素II class Solution {\rpublic boolean containsNearbyDuplicate(int[] nums, int k) {\rHashMap\u0026lt;Integer, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;();\rfor(int i = 0; i \u0026lt; nums.length; i++) {\rint num = nums[i];\rif(hashMap.containsKey(num)) {\rreturn true;\r}\rhashMap.put(num, null);\rif(hashMap.size() \u0026gt; k) {\rhashMap.remove(nums[i - k]);\r}\r}\rreturn false;\r}\r}\r ","permalink":"https://xiaotuanzijiang.github.io/posts/leetcode_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","summary":"1.19_LeetCode-219.存在重复元素II class Solution {\rpublic boolean containsNearbyDuplicate(int[] nums, int k) {\rHashMap\u0026lt;Integer, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;();\rfor(int i = 0; i \u0026lt; nums.length; i++) {\rint num = nums[i];\rif(hashMap.containsKey(num)) {\rreturn true;\r}\rhashMap.put(num, null);\rif(hashMap.size() \u0026gt; k) {\rhashMap.remove(nums[i - k]);\r}\r}\rreturn false;\r}\r}\r ","title":"LeetCode_每日一题"}]