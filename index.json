[{"content":"1. 创建一个新的分支：  git branch newBranch\n 2. 查看分支是否创建成功：  git branch\n 3. 切换到新分区：  git checkout newBranch\n 4. 把代码直接提到newBranch分支上,如果出现提示,直接执行：  git push \u0026ndash;set-upstream origin newBranch\n 5. 切换回本想要提交代码的分区,把newBranch合并到 master分支上：  git checkout master\ngit merge newBranch\n 6. 删除新分区：  git branch -D newBranch\n 7. 重新提交一下代码：  git push\n ","permalink":"https://xiaotuanzijiang.github.io/posts/git%E9%97%AE%E9%A2%98/","summary":"1. 创建一个新的分支：  git branch newBranch\n 2. 查看分支是否创建成功：  git branch\n 3. 切换到新分区：  git checkout newBranch\n 4. 把代码直接提到newBranch分支上,如果出现提示,直接执行：  git push \u0026ndash;set-upstream origin newBranch\n 5. 切换回本想要提交代码的分区,把newBranch合并到 master分支上：  git checkout master\ngit merge newBranch\n 6. 删除新分区：  git branch -D newBranch\n 7. 重新提交一下代码：  git push\n ","title":"Git提交代码时出现Everything up-to-date"},{"content":"前端 - Color - CSSLayout - CSSGridGenerator - Uigradients - FreeDownloads 后端 - Binary Tree - BinaryTreeVisuakuser - Data Structure Visualizations - MvnRepository - MavenRepository - 阿里巴巴开源镜像站 其他 - MarkDown编辑器 - Eclipse主题 - Pexels - CodeLf - Favicon - RegexLearn ","permalink":"https://xiaotuanzijiang.github.io/posts/unitl/","summary":"前端 - Color - CSSLayout - CSSGridGenerator - Uigradients - FreeDownloads 后端 - Binary Tree - BinaryTreeVisuakuser - Data Structure Visualizations - MvnRepository - MavenRepository - 阿里巴巴开源镜像站 其他 - MarkDown编辑器 - Eclipse主题 - Pexels - CodeLf - Favicon - RegexLearn ","title":"UNTIL"},{"content":"LeetCode_每日一题 1.27-2047. 句子中的有效单词数 难度：简单\n 模拟\n class Solution {\rpublic int countValidWords(String sentence) {\rString[] ss = sentence.split(\u0026quot; \u0026quot;);\rint ans = 0;\rfor (String s : ss) if (check(s)) ans++;\rreturn ans;\r}\rboolean check(String s) {\rint n = s.length();\rif (n == 0) return false;\rfor (int i = 0, c1 = 0, c2 = 0; i \u0026lt; n; i++) {\rchar c = s.charAt(i);\rif (Character.isDigit(c)) return false;\rif (c == ' ') return false;\rif (c == '-' \u0026amp;\u0026amp; ++c1 \u0026gt;= 0) {\rif (c1 \u0026gt; 1 || (i == 0 || i == n - 1)) return false;\rif (!Character.isLetter(s.charAt(i - 1)) || !Character.isLetter(s.charAt(i + 1))) return false;\r}\rif ((c == '!' || c == '.' || c == ',') \u0026amp;\u0026amp; ++c2 \u0026gt;= 0) {\rif (c2 \u0026gt; 1 || (i != n - 1)) return false;\r}\r}\rreturn true;\r}\r}\r 1.25-1688. 比赛中的配对次数 难度：简单\n 脑筋急转弯\n class Solution {\rpublic int numberOfMatches(int n) {\rreturn n - 1;\r}\r}\r 1.22-1332. 删除回文子序列 难度：简单\n 模拟\n class Solution {\rpublic int removePalindromeSub(String s) {\rint n = s.length();\rfor(int i = 0; i \u0026lt; (n \u0026gt;\u0026gt; 1); i++)\rif(s.charAt(i) != s.charAt(n-1-i)) return 2;\rreturn 1;\r}\r}\r 1.19-219.存在重复元素II 难度：简单\n HashMap\n class Solution {\rpublic boolean containsNearbyDuplicate(int[] nums, int k) {\rHashMap\u0026lt;Integer, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;();\rfor(int i = 0; i \u0026lt; nums.length; i++) {\rint num = nums[i];\rif(hashMap.containsKey(num)) {\rreturn true;\r}\rhashMap.put(num, null);\rif(hashMap.size() \u0026gt; k) {\rhashMap.remove(nums[i - k]);\r}\r}\rreturn false;\r}\r}\r LeetCode_周赛 第 276 场周赛 2138. 将字符串拆分为若干长度为 k 的组 难度：简单\n 补全分割\n class Solution {\rpublic String[] divideString(String s, int k, char fill) {\rint num = s.length() % k;\rif(num != 0) {\rnum = k - num;\rwhile(num-- \u0026gt; 0) {\rs += fill;\r}\r}\rint len = s.length() / k;\rString[] ans = new String[len];\rfor(int i = 0; i \u0026lt; len; i++) {\rans[i] = s.substring(i*k, (i + 1) * k);\r}\rreturn ans;\r}\r}\r 2139. 得到目标值的最少行动次数 难度：中等\n 贪心\n class Solution {\rpublic int minMoves(int target, int maxDoubles) {\rint cnt = 0;\rwhile(target \u0026gt; 1) {\rif(maxDoubles \u0026gt; 0) {\rif((target \u0026amp; 1) == 1) target--;\relse {\rtarget \u0026gt;\u0026gt;= 1;\rmaxDoubles--;\r}\rcnt++;\r}else {\rreturn target + cnt - 1;\r}\r}\rreturn cnt;\r}\r}\r 2140. 解决智力问题 难度：中等\n 逆序dp\n class Solution {\rpublic long mostPoints(int[][] questions) {\rint n = questions.length;\rlong[] dp = new long[n + 1];\rfor(int i = n -1; i \u0026gt;= 0; i--) {\rif(questions[i][1] + i + 1 \u0026lt; n) {\rdp[i] = Math.max(dp[i + 1], dp[questions[i][1] + i + 1] + questions[i][0]);\r} else {\rdp[i] = Math.max(dp[i + 1], questions[i][0]);\r}\r}\rreturn dp[0];\r}\r}  第 275 场周赛 2133. 检查是否每一行每一列都包含全部整数 难度：简单\n HashSet\n class Solution {\rpublic boolean checkValid(int[][] matrix) {\rint len = matrix.length;\rHashSet\u0026lt;Integer\u0026gt; h1 = new HashSet\u0026lt;\u0026gt;();\rHashSet\u0026lt;Integer\u0026gt; h2 = new HashSet\u0026lt;\u0026gt;();\rfor(int i = 0; i \u0026lt; len; i++) {\rfor(int j = 0; j \u0026lt; len; j++) {\rh1.add(matrix[i][j]);\rh2.add(matrix[j][i]);\r}\rif(h1.size() != len || h2.size() != len) return false;\rh1.clear();\rh2.clear();\r}\rreturn true;\r}\r}\t 第 69 场双周赛 2129. 将标题首字母大写 难度：简单\n Api+Ascii\n class Solution {\rpublic String capitalizeTitle(String title) {\rString[] str = title.split(\u0026quot; \u0026quot;);\rfor(int i = 0; i \u0026lt; str.length; i++) {\rif(str[i].length() \u0026lt; 3) {\rstr[i] = str[i].toLowerCase();\r} else {\rchar[] c = str[i].toLowerCase().toCharArray();\rc[0] \u0026amp;= ~32;\rstr[i] = String.valueOf(c);\r}\r}\rreturn String.join(\u0026quot; \u0026quot;, str);\r}\r}\r 2130. 链表最大孪生和 难度：中等\n 链表转数组+双指针\n class Solution {\rpublic int pairSum(ListNode head) {\rif(head.next == null) return 0;\rList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;();\rwhile(head != null) {\rlist.add(head.val);\rhead = head.next;\r}\rInteger[] num = list.toArray(new Integer[0]);\rint mid = num.length \u0026gt;\u0026gt; 1;\rint max = 0;\rfor(int i = mid - 1; i \u0026gt;= 0; i--){\rmax = Math.max(max, num[i] + num[mid++]);\r}\rreturn max;\r}\r}\r 第 274 场周赛 2124. 检查是否所有 A 都在 B 之前 难度：简单\n 标记\n class Solution {\rpublic boolean checkString(String s) {\rchar[] cs = s.toCharArray();\rboolean na = false;\rfor(char c : cs) {\rif(c == 'a' \u0026amp;\u0026amp; na) return false;\rif(c != 'a') na = true;\r}\rreturn true;\r}\r}\r 2125. 银行中的激光束数量 难度：中等\n cnt * pre\n class Solution {\rpublic int numberOfBeams(String[] bank) {\rint ans = 0;\rint pre = 0;\rfor(String s : bank) {\rint cnt = 0;\rchar[] cs = s.toCharArray();\rfor(int i = 0; i \u0026lt; cs.length; i++) {\rcnt += cs[i] == '1' ? 1 : 0;\r}\rif(cnt != 0) {\rans += cnt * pre;\rpre = cnt;\r}\r}\rreturn ans;\r}\r}\r 2126. 摧毁小行星 难度：中等\n 排序+贪心\n class Solution {\rpublic boolean asteroidsDestroyed(int mass, int[] asteroids) {\rlong mas = mass;\rArrays.sort(asteroids);\rfor(int i : asteroids) {\rif(mas \u0026lt; i) return false;\rmas += i;\r}\rreturn true;\r}\r}\r 第 273 场周赛 2119. 反转两次的数字 难度：简单\n 末尾不为0\n class Solution {\rpublic boolean isSameAfterReversals(int num) {\rreturn !(num != 0 \u0026amp;\u0026amp; num % 10 == 0);\r}\r}\r LeetCode_Other 169. 多数元素 难度：简单\n 脑筋急转弯\n class Solution {\rpublic int majorityElement(int[] nums) {\rArrays.sort(nums);\rreturn nums[nums.length \u0026gt;\u0026gt; 1];\r}\r}\r  摩尔投票法\n class Solution {\rpublic int majorityElement(int[] nums) {\rint cnt = 0;\rint temp = 0;\rfor(int i : nums) {\rif(cnt == 0) {\rtemp = i;\rcnt = 1;\r}else {\rcnt += temp != i ? -1 : 1;\r}\r}\rreturn temp;\r}\r} ","permalink":"https://xiaotuanzijiang.github.io/posts/leetcode/","summary":"LeetCode_每日一题 1.27-2047. 句子中的有效单词数 难度：简单\n 模拟\n class Solution {\rpublic int countValidWords(String sentence) {\rString[] ss = sentence.split(\u0026quot; \u0026quot;);\rint ans = 0;\rfor (String s : ss) if (check(s)) ans++;\rreturn ans;\r}\rboolean check(String s) {\rint n = s.length();\rif (n == 0) return false;\rfor (int i = 0, c1 = 0, c2 = 0; i \u0026lt; n; i++) {\rchar c = s.charAt(i);\rif (Character.","title":"LeetCode"}]